<!DOCTYPE html>
<head>
  <title>Ruby Classes</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog.css">
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73111157-1', 'auto');
  ga('send', 'pageview');
  </script>
</head>
<body>
  <nav>
    <a id="logo" href=../index.html>GWOZ</a>
    <a href="../contact/index.html">Contact</a>
    <a href=#>Services</a>
    <a href=#>Projects</a>
    <a href="../blog/index.html">Blog</a>
  </nav>
  <header>
  <h2>Ruby Classes</h2>
  <h3>What goes where and why? Translating a real world object to a class</h3>
  <h4>2/3/2016</h4>
  </header>
  <section id="post">
    <p>This post aims to give you some clarity around what a class actually is and describe building and using classes.</p>
    <p>We all know that everything in ruby is an object. Underneath that object umbrella you have Classes of objects such as Strings, Integers, Arrays, and Hashes. Classes are basically just a blueprint for what those types of objects can do. For example, in the code below I am using a built-in method for the Integer Class in order to determine whether that number is even.</p>
    <code>6.even? <br/>
    => true
    </code>
    <p>Using existing Classes is great and Ruby includes a lot of tools in the form of classes already, but it doesn't have everything. This is where you come in. To illustrate the concept of a Class let's take a refrigerator and turn it into one. We want to be able to define the attributes of a refrigerator such as name, color, and contents. We also want to be able to define what the refrigerator can do such as open/close, turn on/off, or increase/decrease the temperature. I'm not aware of any Ruby Class that can do all of this, so let's make one!</p>
    <code>class Refrigerator<br/>
      <br/>  
      attr_reader :name, :color, :contents, :power, :temperature<br/> 
      <br/>
      def initialize(name,color)<br/>
      @name = name<br/>
      @color = color<br/>
      @contents = []<br/>
      @power = "Off"<br/>
      @temperature = 0<br/>
      end<br/>
      <br/>
      def add=(food)<br/>
      @contents.push(food)<br/>
      end<br/>
      <br/>
      def power<br/>
        if @power == "On"<br/>
          @power = "Off"<br/>
        elsif @power == "Off"<br/>
          @power = "On"<br/>
      end<br/>
      <br/>
      def temperature=(new_temp)<br/>
        @temperature = new_temp<br/>
      end<br/>   
      <br/>
      end<br/>
      <br/>  
      our_new_fridge = Refrigerator.new("Whirlpool","Black")<br/>
    </code>
    <p>The first thing we do is tell Ruby that we're making a new class. Next we indicate which attributes are available to be accessed outside of the class. This is helpful if we want to be able to see the name, color, or contents later on. With initialize we have instructions for instantiation of an object.</p>
    <p>Instantiation sounds scary, but it's really a simple concept. It just means that when Ruby uses the Refrigerator blueprint to create a new one, that refrigerator should come pre-loaded with certain information in the form of instance variables. This can be user-defined information such as name and color or it can be default information such as whether the power is on/off and the temperature. Think about buying a fridge. You probably specify the name of the fridge and the color you want, but I doubt it will be already be full of contents, turned on, and set at the right temperature when it's delivered to your house. You can see instantiation at work on the last row.</p>
    <p>Moving down the Refrigerator class we also some methods like add_food, power, and temperature. Methods allow us to interact with an object to see an attribute or even to change one. We can turn the fridge on/off using the power method, set the temperature using our temperature input, and put food inside of it using add_food.</p>
    <p>Now that we have these attributes for our fridge (power on/off, contents, temperature) we may want to access with them. Because they are instance variables and can be read from outside the class, we can do things like check what's in the fridge to see if we need to buy anything. Here's how we might do that:</p>
    <code>our_new_fridge.contents<br/>
      => []
    </code>
    <p>As you can see above there's nothing in our fridge yet. Looks like it's time to go grocery shopping!</p>
    <p>Since we've set them as read-only, we can't change them. Our fridge power can be only "On" or "Off". It's not possible for the power to be set as "Green" or "Tuna" so by defining the methods and the instance variables this way, we ensure our fridge stays in excellent working condition!</p>
    <p>I hope this has made classes more clear for you. Come back soon!</p>
  </section>    
<footer>
</footer>
</body>
